export const formatOptions: Record<string, string[]> = {
  video: ["mp4", "mov", "webm", "mkv"],
  audio: ["mp3", "wav", "ogg", "m4a"],
  image: ["png", "jpg", "webp", "gif"],
  document: ["pdf", "docx", "csv", "json"],
};

export const formatMimeMap: Record<string, string> = {
  mp4: "video/mp4",
  mov: "video/quicktime",
  webm: "video/webm",
  mkv: "video/x-matroska",
  mp3: "audio/mpeg",
  wav: "audio/wav",
  ogg: "audio/ogg",
  m4a: "audio/mp4",
  png: "image/png",
  jpg: "image/jpeg",
  jpeg: "image/jpeg",
  webp: "image/webp",
  gif: "image/gif",
  pdf: "application/pdf",
  docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  csv: "text/csv",
  json: "application/json",
};

export interface GeneratorOptions {
  type: string;
  format: string;
  size: number;
  duration?: number;
  metadata?: Record<string, boolean>;
}

// Minimal valid PNG (1x1 transparent pixel)
function createPngBuffer(targetSize: number): Buffer {
  const minPng = Buffer.from([
    0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, // PNG signature
    0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, // IHDR chunk
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, // 1x1 dimensions
    0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0x15, 0xC4, 0x89, // depth, color type, CRC
    0x00, 0x00, 0x00, 0x0A, 0x49, 0x44, 0x41, 0x54, // IDAT chunk
    0x78, 0x9C, 0x63, 0x00, 0x01, 0x00, 0x00, 0x05, 0x00, 0x01, // compressed data
    0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, // IEND chunk
    0xAE, 0x42, 0x60, 0x82 // IEND CRC
  ]);
  
  if (targetSize <= minPng.length) return minPng;
  
  // Pad with ancillary chunks to reach target size
  const padding = Buffer.alloc(targetSize - minPng.length);
  return Buffer.concat([minPng.slice(0, -12), padding, minPng.slice(-12)]);
}

// Minimal valid JPEG
function createJpegBuffer(targetSize: number): Buffer {
  const minJpeg = Buffer.from([
    0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01, // JFIF header
    0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00,
    0xFF, 0xDB, 0x00, 0x43, 0x00, // Quantization table
    0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07,
    0x07, 0x07, 0x09, 0x09, 0x08, 0x0A, 0x0C, 0x14,
    0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12, 0x13,
    0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A,
    0x1C, 0x1C, 0x20, 0x24, 0x2E, 0x27, 0x20, 0x22,
    0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29, 0x2C,
    0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27, 0x39,
    0x3D, 0x38, 0x32, 0x3C, 0x2E, 0x33, 0x34, 0x32,
    0xFF, 0xC0, 0x00, 0x0B, 0x08, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x11, 0x00, // SOF
    0xFF, 0xC4, 0x00, 0x1F, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, // DHT
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
    0xFF, 0xDA, 0x00, 0x08, 0x01, 0x01, 0x00, 0x00, 0x3F, 0x00, 0x7F, 0xFF, 0xD9 // SOS + EOI
  ]);
  
  if (targetSize <= minJpeg.length) return minJpeg;
  
  // Insert padding before EOI marker
  const padding = Buffer.alloc(targetSize - minJpeg.length, 0x00);
  return Buffer.concat([minJpeg.slice(0, -2), padding, minJpeg.slice(-2)]);
}

// Valid PDF
function createPdfBuffer(targetSize: number): Buffer {
  const pdf = `%PDF-1.4
1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj
2 0 obj
<< /Type /Pages /Kids [3 0 R] /Count 1 >>
endobj
3 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R >>
endobj
4 0 obj
<< /Length 44 >>
stream
BT /F1 12 Tf 100 700 Td (FileMock Test PDF) Tj ET
endstream
endobj
xref
0 5
0000000000 65535 f 
0000000009 00000 n 
0000000058 00000 n 
0000000115 00000 n 
0000000206 00000 n 
trailer
<< /Size 5 /Root 1 0 R >>
startxref
300
%%EOF`;
  
  const pdfBuffer = Buffer.from(pdf);
  if (targetSize <= pdfBuffer.length) return pdfBuffer;
  
  // Add padding as comments
  const paddingSize = targetSize - pdfBuffer.length;
  const padding = Buffer.alloc(paddingSize, 0x20); // spaces
  return Buffer.concat([pdfBuffer.slice(0, -6), Buffer.from("\n% "), padding, Buffer.from("\n%%EOF")]);
}

// Valid JSON
function createJsonBuffer(targetSize: number): Buffer {
  const baseJson = {
    _filemock: {
      generator: "filemock-cli",
      version: "1.0.0",
      timestamp: new Date().toISOString(),
      description: "Test JSON file generated by FileMock"
    },
    data: [] as string[]
  };
  
  let json = JSON.stringify(baseJson, null, 2);
  
  // Add data to reach target size
  while (Buffer.from(json).length < targetSize) {
    baseJson.data.push("Lorem ipsum dolor sit amet, consectetur adipiscing elit. ".repeat(10));
    json = JSON.stringify(baseJson, null, 2);
    if (Buffer.from(json).length >= targetSize) break;
  }
  
  return Buffer.from(json.slice(0, targetSize));
}

// Valid CSV
function createCsvBuffer(targetSize: number): Buffer {
  let csv = "id,name,email,created_at,value\n";
  let id = 1;
  
  while (Buffer.from(csv).length < targetSize) {
    csv += `${id},User ${id},user${id}@example.com,${new Date().toISOString()},${Math.random().toFixed(4)}\n`;
    id++;
  }
  
  return Buffer.from(csv.slice(0, targetSize));
}

// Valid WAV audio (silence)
function createWavBuffer(targetSize: number): Buffer {
  const sampleRate = 44100;
  const bitsPerSample = 16;
  const channels = 1;
  const dataSize = Math.max(targetSize - 44, 0); // WAV header is 44 bytes
  
  const header = Buffer.alloc(44);
  header.write('RIFF', 0);
  header.writeUInt32LE(36 + dataSize, 4);
  header.write('WAVE', 8);
  header.write('fmt ', 12);
  header.writeUInt32LE(16, 16); // fmt chunk size
  header.writeUInt16LE(1, 20); // PCM format
  header.writeUInt16LE(channels, 22);
  header.writeUInt32LE(sampleRate, 24);
  header.writeUInt32LE(sampleRate * channels * bitsPerSample / 8, 28);
  header.writeUInt16LE(channels * bitsPerSample / 8, 32);
  header.writeUInt16LE(bitsPerSample, 34);
  header.write('data', 36);
  header.writeUInt32LE(dataSize, 40);
  
  const data = Buffer.alloc(dataSize, 0); // silence
  return Buffer.concat([header, data]);
}

// Fallback placeholder for unsupported formats
function createPlaceholderBuffer(options: GeneratorOptions): Buffer {
  const { type, format, size, duration, metadata } = options;
  const bytes = Math.round(size * 1024 * 1024);
  
  const descriptor = Buffer.from(
    `FileMock Placeholder File\n` +
    `Type: ${type}\nFormat: ${format}\nSize: ${size} MB\n` +
    `Duration: ${duration || 0}s\nMetadata: ${JSON.stringify(metadata || {})}\n` +
    `Generated at: ${new Date().toISOString()}\n` +
    `Note: This is a placeholder file for testing file size/upload. ` +
    `Video/audio formats require proper encoding to be playable.\n`
  );
  
  const buffer = Buffer.alloc(bytes);
  for (let i = 0; i < bytes; i += 1) {
    buffer[i] = descriptor[i % descriptor.length];
  }
  
  return buffer;
}

export function generateFileBuffer(options: GeneratorOptions): Buffer {
  const { format, size } = options;
  const targetSize = Math.round(size * 1024 * 1024);
  const fmt = format.toLowerCase();
  
  switch (fmt) {
    case "png":
      return createPngBuffer(targetSize);
    case "jpg":
    case "jpeg":
      return createJpegBuffer(targetSize);
    case "pdf":
      return createPdfBuffer(targetSize);
    case "json":
      return createJsonBuffer(targetSize);
    case "csv":
      return createCsvBuffer(targetSize);
    case "wav":
      return createWavBuffer(targetSize);
    default:
      // For video and other complex formats, use placeholder
      return createPlaceholderBuffer(options);
  }
}

export function getMimeType(format: string): string {
  return formatMimeMap[format.toLowerCase()] ?? "application/octet-stream";
}

// Check if format produces openable files
export function isOpenableFormat(format: string): boolean {
  return ["png", "jpg", "jpeg", "pdf", "json", "csv", "wav"].includes(format.toLowerCase());
}
